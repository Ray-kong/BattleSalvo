<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShootingStrategy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pa04</a> &gt; <a href="index.source.html" class="el_package">cs3500.pa03.model</a> &gt; <span class="el_source">ShootingStrategy.java</span></div><h1>ShootingStrategy.java</h1><pre class="source lang-java linenums">package cs3500.pa03.model;

import cs3500.pa03.model.enumerations.CoordType;
import cs3500.pa03.model.enumerations.Orientation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * This class defines a shooting strategy for a game of Battleships.
 */
public class ShootingStrategy {
  private Coord[][] enemyBoard;
  private List&lt;Coord&gt; previousShots;
  private List&lt;Coord&gt; shotsEveryThree;
  private List&lt;Ship&gt; myShips;
  private int curX;
  private int curY;

  /**
   * Constructs a new ShootingStrategy with the given boards, previous shots and ships.
   *
   * @param enemyBoard    2D array representing the enemy's board.
   * @param previousShots List of all previous shots.
   * @param myShips       List of all player's ships.
   */
  public ShootingStrategy(
<span class="fc" id="L29">      Coord[][] enemyBoard, List&lt;Coord&gt; previousShots, List&lt;Ship&gt; myShips) {</span>
<span class="fc" id="L30">    this.enemyBoard = enemyBoard;</span>
<span class="fc" id="L31">    this.previousShots = previousShots;</span>
<span class="fc" id="L32">    this.shotsEveryThree = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L33">    this.myShips = myShips;</span>

    //shotsEveryThree
<span class="fc" id="L36">    int startX = curX;</span>
<span class="pc bpc" id="L37" title="1 of 4 branches missed.">    while (curX &lt; enemyBoard.length &amp;&amp; curY &lt; enemyBoard[0].length) {</span>
<span class="fc" id="L38">      shotsEveryThree.add(new Coord(curX, curY));</span>

      // Check if curX + 3 is within bounds before incrementing
<span class="fc bfc" id="L41" title="All 2 branches covered.">      if (curX + 3 &lt; enemyBoard.length) {</span>
<span class="fc" id="L42">        curX += 3;</span>
      } else {
        // Move to next row, but ensure startX is within bounds
<span class="fc" id="L45">        startX = (startX + 1) % 3;</span>
<span class="fc" id="L46">        curX = startX;</span>
<span class="fc" id="L47">        curY++;</span>
      }
    }
<span class="fc" id="L50">  }</span>

  /**
   * Generates a list of shot coordinates.
   *
   * @return A list of shot coordinates.
   */
  public List&lt;Coord&gt; generateShots() {
<span class="fc" id="L58">    List&lt;Coord&gt; isolatedHits = getIsolatedHits();</span>
<span class="fc" id="L59">    List&lt;HitGrouping&gt; allGroups =</span>
<span class="fc" id="L60">        getGroupings(Orientation.VERTICAL, enemyBoard.length, enemyBoard[0].length);</span>
<span class="fc" id="L61">    List&lt;HitGrouping&gt; hzGroups =</span>
<span class="fc" id="L62">        getGroupings(Orientation.HORIZONTAL, enemyBoard.length, enemyBoard[0].length);</span>
<span class="fc" id="L63">    allGroups.addAll(hzGroups);</span>

<span class="fc" id="L65">    List&lt;Coord&gt; surroundAll = generateAllPossibleShots(isolatedHits, allGroups);</span>

<span class="fc" id="L67">    List&lt;List&lt;Coord&gt;&gt; categorizedEnemyBoard = categorizeEnemyBoard();</span>
<span class="fc" id="L68">    List&lt;Coord&gt; emptySpaces = categorizedEnemyBoard.get(0);</span>
<span class="fc" id="L69">    List&lt;Coord&gt; hits = categorizedEnemyBoard.get(1);</span>

<span class="fc" id="L71">    Collections.shuffle(emptySpaces);</span>
<span class="fc" id="L72">    List&lt;Coord&gt; availableAdjacents = surroundAllCoords(hits);</span>
<span class="fc" id="L73">    surroundAll.addAll(availableAdjacents);</span>
<span class="fc" id="L74">    surroundAll = filterOutPreviousAndRepeatedShots(surroundAll);</span>

<span class="fc" id="L76">    int totalShots = calculateTotalShots();</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">    if (emptySpaces.size() &lt; totalShots) {</span>
<span class="nc" id="L78">      return emptySpaces;</span>
    }

<span class="fc" id="L81">    surroundAll = fillUpSurroundAll(surroundAll, totalShots, emptySpaces);</span>
<span class="fc" id="L82">    List&lt;Coord&gt; shots = prepareShots(surroundAll, totalShots);</span>
<span class="fc" id="L83">    updateShotsAndEnemyBoard(shots);</span>

<span class="fc" id="L85">    return shots;</span>
  }

  /**
   * Calculates the total number of shots.
   *
   * @return The total number of shots.
   */
  private int calculateTotalShots() {
<span class="fc" id="L94">    int totalShots = 0;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">    for (Ship s : myShips) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">      if (!s.isSunk()) {</span>
<span class="fc" id="L97">        totalShots++;</span>
      }
<span class="fc" id="L99">    }</span>
<span class="fc" id="L100">    return totalShots;</span>
  }

  /**
   * Generates all possible next shots given a list of isolated hits and groupings.
   *
   * @param isolatedHits A list of isolated hit coordinates.
   * @param allGroups    A list of hit groupings.
   * @return A list of possible next shot coordinates.
   */
  private List&lt;Coord&gt; generateAllPossibleShots(List&lt;Coord&gt; isolatedHits,
                                               List&lt;HitGrouping&gt; allGroups) {
<span class="fc" id="L112">    List&lt;Coord&gt; surroundAll = surroundAllCoords(isolatedHits);</span>
<span class="fc" id="L113">    List&lt;Coord&gt; surroundGroups = surroundAllGroupings(allGroups);</span>
<span class="fc" id="L114">    surroundAll.addAll(surroundGroups);</span>
<span class="fc" id="L115">    return surroundAll;</span>
  }

  /**
   * Categorizes all the coordinates on the enemy board into hits and empty spaces.
   *
   * @return A list containing two lists - the first list is of empty space coordinates
   *         and the second is of hit coordinates.
   */
  private List&lt;List&lt;Coord&gt;&gt; categorizeEnemyBoard() {
<span class="fc" id="L125">    List&lt;Coord&gt; emptySpaces = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L126">    List&lt;Coord&gt; hits = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    for (Coord[] coords : enemyBoard) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">      for (int r = 0; r &lt; coords.length; r++) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (coords[r].getType().equals(CoordType.HIT)) {</span>
<span class="fc" id="L130">          hits.add(coords[r]);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        } else if (coords[r].getType().equals(CoordType.EMPTY)) {</span>
<span class="fc" id="L132">          emptySpaces.add(coords[r]);</span>
        }
      }
    }
<span class="fc" id="L136">    return Arrays.asList(emptySpaces, hits);</span>
  }

  /**
   * Filters out repeated and previous shots from a given list of coordinates.
   *
   * @param coords A list of coordinates.
   * @return A list of unique coordinates that were not previously shot.
   */
  private List&lt;Coord&gt; filterOutPreviousAndRepeatedShots(List&lt;Coord&gt; coords) {
<span class="fc" id="L146">    List&lt;Coord&gt; temp = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">    for (Coord c : coords) {</span>
<span class="fc bfc" id="L148" title="All 4 branches covered.">      if (!temp.contains(c) &amp;&amp; !previousShots.contains(c)) {</span>
<span class="fc" id="L149">        temp.add(c);</span>
      }
<span class="fc" id="L151">    }</span>
<span class="fc" id="L152">    return temp;</span>
  }

  /**
   * Updates the enemy board and previous shots list with the given list of shots.
   *
   * @param shots A list of shots to be updated.
   */
  private void updateShotsAndEnemyBoard(List&lt;Coord&gt; shots) {
<span class="fc" id="L161">    previousShots.addAll(shots);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">    for (Coord c : shots) {</span>
<span class="fc" id="L163">      enemyBoard[c.getX()][c.getY()] = new Coord(c.getX(), c.getY(), CoordType.MISS);</span>
<span class="fc" id="L164">    }</span>
<span class="fc" id="L165">  }</span>

  /**
   * Fills up the surroundAll array until it reaches the totalShots count.
   *
   * @param surroundAll A list of surrounding coordinates.
   * @param totalShots  The total number of shots.
   * @param emptySpaces A list of empty spaces on the board.
   * @return A list of coordinates filled up until it reaches the total shots count.
   */
  private List&lt;Coord&gt; fillUpSurroundAll(List&lt;Coord&gt; surroundAll, int totalShots,
                                        List&lt;Coord&gt; emptySpaces) {
<span class="fc bfc" id="L177" title="All 2 branches covered.">    while (surroundAll.size() &lt; totalShots) {</span>
<span class="fc" id="L178">      List&lt;Coord&gt; pattern = getNextByThree(totalShots - surroundAll.size());</span>
<span class="fc" id="L179">      surroundAll.addAll(pattern);</span>

<span class="pc bpc" id="L181" title="2 of 4 branches missed.">      if (shotsEveryThree.size() == 0 || pattern.size() == 0) {</span>
<span class="nc" id="L182">        surroundAll.addAll(emptySpaces);</span>
      }

<span class="fc" id="L185">      surroundAll = filterOutPreviousAndRepeatedShots(surroundAll);</span>
<span class="fc" id="L186">    }</span>
<span class="fc" id="L187">    return surroundAll;</span>
  }

  /**
   * Prepares a list of shots from the surroundAll array.
   *
   * @param surroundAll A list of surrounding coordinates.
   * @param totalShots  The total number of shots.
   * @return A list of shot coordinates.
   */
  private List&lt;Coord&gt; prepareShots(List&lt;Coord&gt; surroundAll, int totalShots) {
<span class="fc" id="L198">    List&lt;Coord&gt; shots = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    for (int i = 0; i &lt; totalShots; i++) {</span>
<span class="fc" id="L200">      shots.add(surroundAll.get(i));</span>
    }
<span class="fc" id="L202">    return shots;</span>
  }

  /**
   * Calculates the next set of shots in a &quot;three-step&quot; pattern, to systematically cover the board.
   *
   * @param totalShots The total number of shots to generate.
   * @return A list of coordinates for the next shots.
   */
  private List&lt;Coord&gt; getNextByThree(int totalShots) {
<span class="fc" id="L212">    List&lt;Coord&gt; shots = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">    if (totalShots &gt; shotsEveryThree.size()) {</span>
<span class="nc" id="L214">      shotsEveryThree = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L215">      return shotsEveryThree;</span>
    } else {
<span class="fc bfc" id="L217" title="All 2 branches covered.">      for (int i = 0; i &lt; totalShots; i++) {</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        while (!shotsEveryThree.get(0).getType().equals(CoordType.EMPTY)) {</span>
<span class="nc" id="L219">          shotsEveryThree.remove(0);</span>
        }
<span class="fc" id="L221">        shots.add(shotsEveryThree.get(0));</span>
<span class="fc" id="L222">        shotsEveryThree.remove(0);</span>
      }
    }
<span class="fc" id="L225">    return shots;</span>
  }

  /**
   * Generates a list of coordinates surrounding the given hits,
   * used to check the area around known hits for further targets.
   *
   * @param isolated List of hit coordinates to find surrounding area.
   * @return A list of coordinates surrounding the given hits.
   */
  private List&lt;Coord&gt; surroundAllCoords(List&lt;Coord&gt; isolated) {
<span class="fc" id="L236">    List&lt;Coord&gt; shots = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L237">    int boardWidth = enemyBoard.length;</span>
<span class="fc" id="L238">    int boardHeight = enemyBoard[0].length;</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">    for (Coord c : isolated) {</span>
<span class="fc" id="L241">      int x = c.getX();</span>
<span class="fc" id="L242">      int y = c.getY();</span>

      // check left
<span class="fc bfc" id="L245" title="All 4 branches covered.">      if (x != 0 &amp;&amp; enemyBoard[x - 1][y].getType().equals(CoordType.EMPTY)) {</span>
<span class="fc" id="L246">        shots.add(enemyBoard[x - 1][y]);</span>
      }
      // check right
<span class="fc bfc" id="L249" title="All 4 branches covered.">      if (x != boardWidth - 1 &amp;&amp; enemyBoard[x + 1][y].getType().equals(CoordType.EMPTY)) {</span>
<span class="fc" id="L250">        shots.add(enemyBoard[x + 1][y]);</span>
      }
      // check up
<span class="fc bfc" id="L253" title="All 4 branches covered.">      if (y != 0 &amp;&amp; enemyBoard[x][y - 1].getType().equals(CoordType.EMPTY)) {</span>
<span class="fc" id="L254">        shots.add(enemyBoard[x][y - 1]);</span>
      }
      // check down
<span class="fc bfc" id="L257" title="All 4 branches covered.">      if (y != boardHeight - 1 &amp;&amp; enemyBoard[x][y + 1].getType().equals(CoordType.EMPTY)) {</span>
<span class="fc" id="L258">        shots.add(enemyBoard[x][y + 1]);</span>
      }
<span class="fc" id="L260">    }</span>
<span class="fc" id="L261">    return shots;</span>
  }

  /**
   * Generates a list of coordinates surrounding the given groups of hits,
   * used to check the area around known hit groups for further targets.
   *
   * @param groups List of hit groupings to find surrounding area.
   * @return A list of coordinates surrounding the given hit groups.
   */
  private List&lt;Coord&gt; surroundAllGroupings(List&lt;HitGrouping&gt; groups) {
<span class="fc" id="L272">    List&lt;Coord&gt; shots = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (HitGrouping hg : groups) {</span>
<span class="fc" id="L274">      shots.addAll(hg.getUncheckedSides(enemyBoard));</span>
<span class="fc" id="L275">    }</span>
<span class="fc" id="L276">    return shots;</span>
  }

  /**
   * Identifies isolated hit locations on the enemy board.
   *
   * @return A list of isolated hit locations.
   */
  private List&lt;Coord&gt; getIsolatedHits() {
<span class="fc" id="L285">    List&lt;Coord&gt; output = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">    for (int c = 0; c &lt; enemyBoard.length; c++) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">      for (int r = 0; r &lt; enemyBoard[c].length; r++) {</span>
<span class="fc bfc" id="L288" title="All 4 branches covered.">        if (enemyBoard[c][r].getType() == CoordType.HIT &amp;&amp; checkIsolated(c, r)) {</span>
<span class="fc" id="L289">          output.add(enemyBoard[c][r]);</span>
        }
      }
    }
<span class="fc" id="L293">    return output;</span>
  }

  /**
   * Checks if a given coordinate is isolated, i.e., it does not have any adjacent hits.
   *
   * @param c The column index of the coordinate.
   * @param r The row index of the coordinate.
   * @return True if the coordinate is isolated, false otherwise.
   */
  private boolean checkIsolated(int c, int r) {
<span class="fc bfc" id="L304" title="All 4 branches covered.">    if (c &gt; 0 &amp;&amp; enemyBoard[c - 1][r].getType() == CoordType.HIT) {</span>
<span class="fc" id="L305">      return false;</span>
    }
<span class="fc bfc" id="L307" title="All 4 branches covered.">    if (c &lt; enemyBoard.length - 1 &amp;&amp; enemyBoard[c + 1][r].getType() == CoordType.HIT) {</span>
<span class="fc" id="L308">      return false;</span>
    }
<span class="fc bfc" id="L310" title="All 4 branches covered.">    if (r &gt; 0 &amp;&amp; enemyBoard[c][r - 1].getType() == CoordType.HIT) {</span>
<span class="fc" id="L311">      return false;</span>
    }
<span class="fc bfc" id="L313" title="All 4 branches covered.">    return r &gt;= enemyBoard[c].length - 1 || enemyBoard[c][r + 1].getType() != CoordType.HIT;</span>
  }

  /**
   * Identifies and returns all groupings of hits based on a given orientation.
   *
   * @param orientation The orientation of the groupings to identify.
   * @param width       The width of the enemy board.
   * @param height      The height of the enemy board.
   * @return A list of all identified hit groupings in the given orientation.
   */
  private List&lt;HitGrouping&gt; getGroupings(Orientation orientation, int width, int height) {
<span class="fc" id="L325">    List&lt;HitGrouping&gt; allGroupings = new ArrayList&lt;&gt;();</span>

    // determine if the iteration is vertical or horizontal.
<span class="fc bfc" id="L328" title="All 2 branches covered.">    boolean isVertical = (orientation == Orientation.VERTICAL);</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">    int firstBound = isVertical ? width : height;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">    int secondBound = isVertical ? height : width;</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">    for (int i = 0; i &lt; firstBound; i++) {</span>
<span class="fc" id="L334">      List&lt;Coord&gt; tempGroup = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">      for (int j = 0; j &lt; secondBound; j++) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        int firstIndex = isVertical ? i : j;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        int secondIndex = isVertical ? j : i;</span>

<span class="fc" id="L340">        Coord currentCoord = enemyBoard[firstIndex][secondIndex];</span>

        // if current coordinate is not a hit and we have a group, add it to all groupings
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (!currentCoord.getType().equals(CoordType.HIT)) {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">          if (!tempGroup.isEmpty()) {</span>
<span class="fc" id="L345">            allGroupings.add(new HitGrouping(tempGroup.size(), orientation, tempGroup));</span>
<span class="fc" id="L346">            tempGroup = new ArrayList&lt;&gt;();</span>
          }
        } else {
<span class="fc" id="L349">          tempGroup.add(currentCoord);</span>

          // if it is the last coordinate in the row/column, and it is a hit, add the group
<span class="pc bpc" id="L352" title="1 of 4 branches missed.">          if (j == secondBound - 1 &amp;&amp; !tempGroup.isEmpty()) {</span>
<span class="fc" id="L353">            allGroupings.add(new HitGrouping(tempGroup.size(), orientation, tempGroup));</span>
<span class="fc" id="L354">            tempGroup = new ArrayList&lt;&gt;();</span>
          }
        }
      }
    }
<span class="fc" id="L359">    List&lt;HitGrouping&gt; output = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">    for (HitGrouping hg : allGroupings) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      if (hg.coords().size() != 1) {</span>
<span class="fc" id="L362">        output.add(hg);</span>
      }
<span class="fc" id="L364">    }</span>
<span class="fc" id="L365">    return output;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>